<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÌÑ∞Ïπò ÎìúÎ°úÏûâ Ïï±</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #1a202c;
            /* Remove default margin/padding and enable full screen */
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            /* Full-screen canvas */
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            touch-action: none;
            background-color: #ffffff; /* White background */
            z-index: -1;
        }
        .controls {
            /* Position controls at the bottom center */
            position: fixed;
            bottom: 0.5rem; /* Reduced bottom margin */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row; /* Changed to row for horizontal layout */
            justify-content: center;
            align-items: center;
            gap: 0.5rem; /* Gap reduced */
            padding: 0; /* Padding removed */
            background-color: transparent; /* Background removed */
            backdrop-filter: none; /* Backdrop filter removed */
            border-radius: 0;
            box-shadow: none;
            z-index: 10;
        }
        .control-button {
            padding: 0.75rem 2.5rem;
            font-weight: 500;
            border-radius: 9999px;
            transition: transform 0.1s, box-shadow 0.1s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            min-width: 120px;
            font-size: 0.9rem;
        }
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px -1px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        #clear-button {
            background-color: #e53e3e;
            color: white;
        }
        #ai-button {
            background-color: #4299e1;
            color: white;
        }
        #upload-button {
            background-color: #38a169;
            color: white;
        }
        .prediction-box {
            position: fixed;
            top: 0.5rem; /* Reduced top margin */
            right: 0.5rem; /* Reduced right margin */
            padding: 1rem;
            background-color: transparent;
            z-index: 100;
            text-align: center;
            max-width: 250px;
        }
        .ranking-button {
            position: fixed;
            top: 0.5rem;
            left: 0.5rem;
            padding: 0.5rem 1rem;
            background-color: #f39c12;
            color: white;
            border: none;
            border-radius: 9999px;
            font-weight: 500;
            font-size: 0.9rem;
            cursor: pointer;
            z-index: 100;
            transition: transform 0.1s, box-shadow 0.1s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .ranking-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px -1px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .clear-api-button {
            position: fixed;
            top: 4rem; /* Position below ranking button */
            left: 0.5rem; /* Same left position as ranking button */
            padding: 0.5rem 1rem;
            background-color: #e53e3e;
            color: white;
            border: none;
            border-radius: 9999px;
            font-weight: 500;
            font-size: 0.9rem;
            cursor: pointer;
            z-index: 100;
            transition: transform 0.1s, box-shadow 0.1s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .clear-api-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px -1px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .prediction-text {
            font-weight: bold;
            color: #ff0000;
            font-size: 1rem; /* Font size reduced by half */
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 2s linear infinite;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <canvas id="drawing-canvas"></canvas>
    
    <!-- Ranking button in top left corner -->
    <button id="ranking-button" class="ranking-button">üèÜ Îû≠ÌÇπ</button>
    
    <!-- Clear API Key button next to ranking button -->
    <button id="clear-api-button" class="clear-api-button">Clear</button>
    
    <div class="controls">
        <button id="clear-button" class="control-button">ÏßÄÏö∞Í∏∞</button>
        <button id="ai-button" class="control-button">AI</button>
        <button id="upload-button" class="control-button">ÏóÖÎ°úÎìú</button>
    </div>

    <!-- AI ÏòàÏ∏° Í≤∞Í≥º ÌëúÏãúÎ•º ÏúÑÌïú ÏòÅÏó≠ -->
    <div id="prediction-box" class="prediction-box">
        <span class="prediction-text" id="prediction-text">Í∑∏Î¶ºÏùÑ Í∑∏Î¶¨Î©¥ AIÍ∞Ä ÏòàÏ∏°Ìï¥Ïöî!</span>
    </div>
    
    <div class="loader" id="loader"></div>

    <!-- API Key Input Modal -->
    <div id="api-key-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 2rem; border-radius: 1rem; box-shadow: 0 10px 25px rgba(0,0,0,0.2);">
            <h3 style="margin: 0 0 1rem 0; color: #1a202c;">Gemini API ÌÇ§ ÏûÖÎ†•</h3>
            <input type="password" id="api-key-input" placeholder="API ÌÇ§Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî" style="width: 100%; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 0.5rem; margin-bottom: 1rem; box-sizing: border-box;">
            <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                <button id="save-api-key" style="padding: 0.5rem 1rem; background-color: #4299e1; color: white; border: none; border-radius: 0.5rem; cursor: pointer;">Ï†ÄÏû•</button>
                <button id="cancel-api-key" style="padding: 0.5rem 1rem; background-color: #6b7280; color: white; border: none; border-radius: 0.5rem; cursor: pointer;">Ï∑®ÏÜå</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const clearButton = document.getElementById('clear-button');
        const aiButton = document.getElementById('ai-button');
        const uploadButton = document.getElementById('upload-button');
        const rankingButton = document.getElementById('ranking-button');
        const clearApiButton = document.getElementById('clear-api-button');
        const predictionTextElement = document.getElementById('prediction-text');
        const loaderElement = document.getElementById('loader');
        
        // API Key modal elements
        const apiKeyModal = document.getElementById('api-key-modal');
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyButton = document.getElementById('save-api-key');
        const cancelApiKeyButton = document.getElementById('cancel-api-key');
        
        // API Key management
        const API_KEY_STORAGE = 'gemini_api_key';
        
        function getApiKey() {
            return localStorage.getItem(API_KEY_STORAGE);
        }
        
        function setApiKey(key) {
            localStorage.setItem(API_KEY_STORAGE, key);
        }
        
        function clearApiKey() {
            localStorage.removeItem(API_KEY_STORAGE);
            showApiKeyModal(); // Show the API key modal after clearing
        }
        
        function showApiKeyModal() {
            apiKeyModal.style.display = 'block';
            apiKeyInput.focus();
        }
        
        function hideApiKeyModal() {
            apiKeyModal.style.display = 'none';
            apiKeyInput.value = '';
        }
        
        // Check for API key on page load
        window.addEventListener('load', () => {
            if (!getApiKey()) {
                showApiKeyModal();
            }
        });
        
        // API Key modal event listeners
        saveApiKeyButton.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            if (key) {
                setApiKey(key);
                hideApiKeyModal();
            } else {
                alert('API ÌÇ§Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
            }
        });
        
        cancelApiKeyButton.addEventListener('click', hideApiKeyModal);
        
        // Close modal when clicking outside
        apiKeyModal.addEventListener('click', (e) => {
            if (e.target === apiKeyModal) {
                hideApiKeyModal();
            }
        });
        
        // Enter key to save API key
        apiKeyInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveApiKeyButton.click();
            }
        });

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞Î•º ÌôîÎ©¥ Ï†ÑÏ≤¥Ïóê ÎßûÍ≤å Ï°∞Ï†ï
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Ïãú Î∞∞Í≤ΩÏÉâ Îã§Ïãú Ïπ†ÌïòÍ∏∞
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        window.addEventListener('load', () => {
            resizeCanvas();
        });

        window.addEventListener('resize', () => {
            resizeCanvas();
        });

        // ÎìúÎ°úÏûâ ÏãúÏûë
        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = getCoordinates(e);
        }

        // Í∑∏Î¶¨Í∏∞
        function draw(e) {
            if (!isDrawing) return;

            e.preventDefault();

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(...getCoordinates(e));
            ctx.strokeStyle = "#000000"; // Black pencil color
            ctx.lineWidth = 7.5; // Pen width reduced by half
            ctx.lineCap = 'round';
            ctx.stroke();
            [lastX, lastY] = getCoordinates(e);
        }

        // ÎìúÎ°úÏûâ Ï¢ÖÎ£å
        function stopDrawing() {
            isDrawing = false;
        }

        // ÌÑ∞Ïπò Î∞è ÎßàÏö∞Ïä§ Ï¢åÌëú Í∞ÄÏ†∏Ïò§Í∏∞
        function getCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            if (e.touches && e.touches.length > 0) {
                const x = (e.touches[0].clientX - rect.left) * scaleX;
                const y = (e.touches[0].clientY - rect.top) * scaleY;
                return [x, y];
            } else {
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                return [x, y];
            }
        }

        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);

        clearButton.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // After clearing, re-fill the canvas with the background color
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            predictionTextElement.textContent = "Í∑∏Î¶ºÏùÑ Í∑∏Î¶¨Î©¥ AIÍ∞Ä ÏòàÏ∏°Ìï¥Ïöî!";
        });

        aiButton.addEventListener('click', async () => {
            await createDrawingFromAI();
        });

        rankingButton.addEventListener('click', () => {
            window.location.href = '/';
        });
        
        clearApiButton.addEventListener('click', () => {
            clearApiKey();
        });

        uploadButton.addEventListener('click', async () => {
            // Check if canvas is blank
            if (isCanvasBlank(canvas)) {
                alert('Ï∫îÎ≤ÑÏä§Ïóê Í∑∏Î¶ºÏùÑ Í∑∏Î¶∞ ÌõÑ ÏóÖÎ°úÎìúÌï¥ Ï£ºÏÑ∏Ïöî.');
                return;
            }
            
            try {
                // Get the data URL of the canvas
                const dataURL = canvas.toDataURL('image/png');
                
                // Convert data URL to blob
                const response = await fetch(dataURL);
                const blob = await response.blob();
                
                // Create FormData for upload
                const formData = new FormData();
                formData.append('image', blob, 'drawing.png');
                formData.append('description', 'AI Canvas Drawing');
                
                // Show loading indicator
                loaderElement.style.display = 'block';
                
                // Upload to server
                const uploadResponse = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await uploadResponse.json();
                
                if (uploadResponse.ok) {
                    alert(`ÏóÖÎ°úÎìú ÏÑ±Í≥µ! UUID: ${result.uuid}`);
                } else {
                    alert(`ÏóÖÎ°úÎìú Ïã§Ìå®: ${result.error}`);
                }
                
            } catch (error) {
                console.error('ÏóÖÎ°úÎìú Ïò§Î•ò:', error);
                alert('ÏóÖÎ°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
            } finally {
                loaderElement.style.display = 'none';
            }
        });

        // Gemini APIÎ•º ÏÇ¨Ïö©Ìïú Í∑∏Î¶º ÏòàÏ∏° Í∏∞Îä•
        async function predictDrawing() {
            const apiKey = getApiKey();
            if (!apiKey) {
                showApiKeyModal();
                return;
            }
            
            const base64Image = canvas.toDataURL('image/png');
            const base64Data = base64Image.split(',')[1];
            
            // Ï∫îÎ≤ÑÏä§Í∞Ä ÎπÑÏñ¥ÏûàÏúºÎ©¥ ÏòàÏ∏°ÌïòÏßÄ ÏïäÏùå
            if (isCanvasBlank(canvas)) {
                predictionTextElement.textContent = "Í∑∏Î¶ºÏùÑ Í∑∏Î¶¨Î©¥ AIÍ∞Ä ÏòàÏ∏°Ìï¥Ïöî!";
                return;
            }

            try {
                // AI ÏòàÏ∏°Ïóê ÎåÄÌïú ÌîÑÎ°¨ÌîÑÌä∏ ÏàòÏ†ï: Ïó¨Îü¨ Í∞úÏùò ÏÇ¨Î¨ºÏùÑ ÎßêÌïòÍ≥†, Ïï†Îß§Ìïú Í≤ΩÏö∞ ÏßàÎ¨∏ÌïòÎèÑÎ°ù Î≥ÄÍ≤Ω
                const userPrompt = "Ïù¥ Í∑∏Î¶ºÏù¥ Î¨¥ÏóáÏù∏ÏßÄ ÏòàÏ∏°Ìï¥ÏÑú Í∞ÄÏû• Í∞ÄÎä•ÏÑ±Ïù¥ ÎÜíÏùÄ ÏÇ¨Î¨ºÎì§ÏùÑ ÏΩ§ÎßàÎ°ú Íµ¨Î∂ÑÌï¥ÏÑú Ïó¨Îü¨ Í∞ú ÎßêÌï¥Ï§ò. ÏòàÎ•º Îì§Ïñ¥, 'Í∞ïÏïÑÏßÄ, Í≥†ÏñëÏù¥' Ï≤òÎüº. ÎßåÏïΩ Ìïú Îã®Ïñ¥Î°ú ÏòàÏ∏°ÌïòÍ∏∞ Ïñ¥Î†µÎã§Î©¥, 'Ïù¥Í≤ÉÏùÄ [ÏòàÏ∏°1], [ÏòàÏ∏°2]ÏùºÍπåÏöî?' ÏôÄ Í∞ôÏù¥ ÏßàÎ¨∏ÌïòÎäî ÌòïÏãùÏúºÎ°ú ÎåÄÎãµÌï¥Ï§ò.";
                
                const payload = {
                    contents: [
                        {
                            role: "user",
                            parts: [
                                { text: userPrompt },
                                { inlineData: { mimeType: "image/png", data: base64Data } }
                            ]
                        }
                    ],
                };
                
                // API ÌÇ§Î•º URLÏóê Ìè¨Ìï®
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                
                let response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                const prediction = result.candidates?.[0]?.content?.parts?.[0]?.text || "Ïïå Ïàò ÏóÜÏùå";

                predictionTextElement.textContent = prediction;

            } catch (error) {
                console.error("Í∑∏Î¶º ÏòàÏ∏° Ïò§Î•ò:", error);
                predictionTextElement.textContent = "Ïïå Ïàò ÏóÜÏùå";
            }
        }

        // Gemini APIÎ•º ÏÇ¨Ïö©Ìïú Ïï†ÎãàÎ©îÏù¥ÏÖò Ïä§ÌÉÄÏùº Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
        async function createDrawingFromAI() {
            const apiKey = getApiKey();
            if (!apiKey) {
                showApiKeyModal();
                return;
            }
            
            const base64Image = canvas.toDataURL('image/png');
            const base64Data = base64Image.split(',')[1];
            
            // Ï∫îÎ≤ÑÏä§Í∞Ä ÎπÑÏñ¥ÏûàÏúºÎ©¥ ÎèôÏûëÌïòÏßÄ ÏïäÏùå
            if (isCanvasBlank(canvas)) {
                alert('Ï∫îÎ≤ÑÏä§Ïóê Í∑∏Î¶ºÏùÑ Í∑∏Î¶∞ ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.');
                return;
            }
            
            loaderElement.style.display = 'block';

            try {
                // ÌîÑÎ°¨ÌîÑÌä∏ ÏàòÏ†ï: Ïï†ÎãàÎ©îÏù¥ÏÖò Ïä§ÌÉÄÏùºÏóêÏÑú Ïã§ÏÇ¨ ÏÇ¨ÏßÑ Ïä§ÌÉÄÏùºÎ°ú Î≥ÄÍ≤Ω
                const userPrompt = "Transform this sketch into a photorealistic drawing. Add realistic lighting, shadows, and textures. The background should be a natural setting that matches the subject.";
                
                const payload = {
                    contents: [
                        {
                            role: "user",
                            parts: [
                                { text: userPrompt },
                                { inlineData: { mimeType: "image/png", data: base64Data } }
                            ]
                        }
                    ],
                    generationConfig: {
                      responseModalities: ["TEXT", "IMAGE"]
                    }
                };
                
                // API ÌÇ§Î•º URLÏóê Ìè¨Ìï®
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
                
                let response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏßÑ ÌååÌä∏Î•º Ï∞æÎèÑÎ°ù ÏàòÏ†ï
                const result = await response.json();
                const base64DataFromAI = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;

                if (base64DataFromAI) {
                    const img = new Image();
                    img.src = `data:image/png;base64,${base64DataFromAI}`;
                    img.onload = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        loaderElement.style.display = 'none';
                    };
                } else {
                    console.error("AIÍ∞Ä Ïù¥ÎØ∏ÏßÄÎ•º ÏÉùÏÑ±ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§.");
                    alert("AIÍ∞Ä Ïù¥ÎØ∏ÏßÄÎ•º ÏÉùÏÑ±ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.");
                    loaderElement.style.display = 'none';
                }

            } catch (error) {
                console.error("Í∑∏Î¶º ÏÉùÏÑ± Ïò§Î•ò:", error);
                alert("Í∑∏Î¶º ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.");
                loaderElement.style.display = 'none';
                
            }
        }

        // Ï∫îÎ≤ÑÏä§ ÎπÑÏñ¥ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÎäî Ìï®Ïàò
        function isCanvasBlank(canvas) {
            const pixelBuffer = new Uint32Array(ctx.getImageData(0, 0, canvas.width, canvas.height).data.buffer);
            return !pixelBuffer.some(color => color !== 0xFFFFFFFF && color !== 0);
        }

        // 10Ï¥àÎßàÎã§ AI Ìò∏Ï∂ú
        setInterval(predictDrawing, 7000);

    </script>
</body>
</html>
